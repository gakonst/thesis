\chapter{Ethereum and Security} \label{ch:security}

The Ethereum platform itself has proven to be robust and reliable as it has been resistant to both censorship and double-spend attacks\footnote{Double-spending is the act of successfully spending money more than once}. In this chapter we discuss vulnerabilities that have been found in the network implementation of the protocol, the security of smart contracts and the best practices that need to be applied in order to code secure and robust smart contracts. It should be noted that the security of a smart contract is a completely different problem set from the security of the network. We contribute to the existing literature by evaluating the auditing tool \textit{Slither} and comparing it to the performance of other automated auditing tools, which can detect smart contract vulnerabilities and edge cases. We also improved \textit{Slither} by augmenting the scope of vulnerabilities it was able to detect.

\section{Past Attacks} \label{past-attacks}

\subsection{Network Level Attacks}

\paragraph{October 2016 Spam Attacks}
During the period of September-October 2016, an attacker was able to flood the Ethereum network's state by creating 19 million `dead' accounts. The attack was made possible by a mispricing in the SUICIDE opcode of smart contracts, allowing an attacker to submit transactions that created new accounts at a low cost. The creation of these accounts filled the blockchain's state with large amounts of data, which resulted in clients taking long to synchronize, effectively causing a \textit{Denial of Service} attack to the network \cite{eip150faq}. As a response, two hard-forks\footnote{A non-backwards compatible upgrade mechanism that creates new rules for a blockchain, usually to improve the system.} were proposed. The first one, Tangerine Whistle\cite{eip608} solved the gas pricing issue and at a later point, Spurious Dragon\cite{eip608} cleared the world state from the accounts created by the attack. 

\paragraph{Eclipse Attacks on Ethereum}
Eclipse attacks are a type of attack in which an attacker floods a victim node with TCP connections, allowing the attacker to control what blocks are received by the victim. The victim sees a different blockchain than the valid one and this can result in double-spend attacks against vendors who use victim nodes as sources for the state of the blockchain. This is a known and fixed attack on Bitcoin which requires an attacker to control a large number of nodes with unique IP addresses in order to monopolize the outgoing and incoming connections to the victim \cite{cryptoeprint:2015:263}. On the other hand, Eclipse attacks on Ethereum require only a small number of attacking nodes, because it uses a structured network protocol contrary to Bitcoin's unstructured network protocol which makes random connections \cite{cryptoeprint:2018:236}. The attack vector was communicated to the client developers and the vulnerabilities were fixed in \textit{geth} v1.8\footnote{Geth (go-ethereum) is the most popular implementation of the Ethereum protocol in golang}. This vulnerability was not abused in the wild, and as a result there was no need for a hard-fork. It should be noted, that other client implementations such as \textit{parity} or \textit{cpp-ethereum} were not found to be vulnerable, which shows that having a diverse set of implementations of a protocol can contribute to the network's security.

\subsection{Smart Contract Attacks}
Contrary to Ethereum as a network, smart contracts have been exploited multiple times the past. We proceed to give a brief explanation of the three biggest hacks by financial loss in Ethereum smart contracts, the `TheDAO' and the `Parity Multisig 1 and 2'\footnote{A multisig is a multisignature cryptocurrency wallet, in this case a smart contract, which requires more than one cryptographic signatures to perform a transaction. It is widely used by organizations to decrease the chances of funds being stolen as well as to ensure that funds get spent only when all authorized parties agree. The Parity Multisig refers to a multisig wallet implementation by Parity Technologies, \url{https://www.parity.io/}} which involved two independent incidents with the same smart contract.

\subsubsection{TheDAO} \label{thedao}
TheDAO is an acronym for `The Decentralized Autonomous Organization'. The goal of TheDAO was to create a decentralized business fund where token holders would vote on projects worthy of being funded. TheDAO was initially crowdfunded with approximately \$150.000.000, the largest crowdfunding in history, to date. In July 2016 it was proven that the smart contract governing TheDAO was vulnerable to a software exploit which enabled an attacker to steal approximately 3.600.000 ether, worth more than \$50.000.000 at the time~\cite{bloombergdao}.

If a user did not agree with a funding proposal they were able to get their investment back through the \texttt{splitDAO} function in the smart contract. The function was vulnerable to a \textit{reentrancy}\footnote{Essentially because an account's balance was not reduced before performing a withdrawal it was possible for a malicious user to perform multiple consecutive withdrawals and withdraw bigger amounts than their balance allowed.} attack which allowed an attacker to make unlimited withdrawals from the contract~\cite{hackingdistibuteddao}.

What made TheDAO hack very significant was that as a response, part of the Ethereum community decided to perform a hard-fork to negate the mass theft of funds, which was 12\% of Ether in existence at the time~\cite{bloombergdao}. This was not accepted by the whole community, and as a result, users who decided not to follow the hard-fork, stayed on the original unforked chain which is still maintained and is called `Ethereum Classic'~\cite{etc}. 

\subsubsection{Parity Multisig 1}
In July 2017 a vulnerability was found in the Parity Multisig Wallet which allowed an attacker to steal over 150.000 ether \cite{parityhack}. The attack involved a library contract, which contrary to using Solidity's \texttt{Library} pattern discussed in Section \ref{method3}, involves using the \textit{proxy libraries} pattern to extract the functionality of a smart contract and let it be usable by other contracts, in order to reuse code, and reduce gas costs, as best practices dictate~\cite{proxylibraries}.

The vulnerability involved the Library contract's \texttt{initWallet} function which was being called through the Parity Multisig Wallet. The function was called when the contract was initially deployed in order to set up the owners of the multisig wallet, however due to it being unprotected it was callable by any user of the wallet\footnote{\url{https://github.com/paritytech/parity/blob/4d08e7b0aec46443bf26547b17d10cb302672835/js/src/contracts/snippets/enhanced-wallet.sol}}. As a result, a malicious user could reinitialize any multisig with their address as the contract owner and drain the multisig funds.

This was observed by a group of ethical hackers called the `White-Hat Group' who proceeded to drain vulnerable wallets before the attacker could, saving more than \$85.000.000 worth of ether at the time~\cite{swarm-parity}. The primary cause of this hack was due to the irresponsible use of \texttt{delegatecall} and the lack of proper access control on the \texttt{initWallet} function, along with the lack of external auditing of the wallet contracts before deploying to mainnet.

\subsubsection{Parity Multisig 2}
After the first Parity hack, a new multisig wallet library was deployed, with access control in the \texttt{initWallet} function, patching the vulnerability which caused the previous hack. The fix in \texttt{initWallet} involved adding a \texttt{only\_uninitialized} modifier which would only allow modification of the linked multisignature wallet owners during initialization\footnote{\url{https://etherscan.io/address/0x863df6bfa4469f3ead0be8f9f2aae51c91a907b4}}. However, the \texttt{initWallet} function was never called on the library contract itself, leaving the library uninitialized. As a result, any user could call the \texttt{initWallet} function and set themselves as the owner of the library contract. This alone would not have been dangerous, had there not been a \texttt{kill} function in the smart contract, which when called deletes the contract's bytecode, and effectively renders it useless. 

The attacker first became owner of the library by calling \texttt{initWallet} and then proceeded to delete the library by calling the \texttt{kill} function. This resulted in all contracts that were using the library's logic to be rendered useless, effectively \textit{freezing} 513774 Ether, as well as tokens belonging to each project \cite{paritypostmortem}. 

A number of proposals were made in order to recover the locked funds~\cite{eip867, eip999}. All of these would require an `irregular state change' similar to what happened with the DAO and have caused controversy among the ethereum community, before being eventually dismissed.

% https://github.com/paritytech/parity/issues/6995

\section{Evaluating Smart Contract Security}
Due to the high financial amounts often involved with smart contracts, there need to be guarantees that smart contracts are sufficiently secured as well as execute code as intended. Security audits from internal and external parties to the development team are considered a necessary step before deployment to production. It is also common practice for projects to engage in bug-bounties, in which they reward users that responsibly disclose vulnerabilities found in their smart contracts. Comprehensive studies on identifying the security, privacy and scalability of smart contracts as well as taxonomies aiming to organize past smart contract vulnerabilities are being released over time, but due to how often new vulnerabilities surface, they are insufficient to create a whole picture of the smart contract security ecosystem~\cite{DBLP:journals/corr/abs-1710-06372, Atzei:2017:SAE:3080353.3080363,tools}.

In order to improve the security of deployed smart contracts, developers become accustomed to using automated auditing tools as well as use the latest versions of basic tools like the Solidity Compiler. As an example, none of the tools mentioned in \cite{tools} were able to detect the `Uninitialized Storage Pointer' vulnerability\footnote{\url{https://github.com/ethereum/solidity/issues/2628}}, however the Solidity Compiler was later updated to throw a warning if this issue exists. 

\subsection{Automated Tools}\label{slither}

Auditing smart contracts is significantly more effective when the source code is available. Taking into account the tools which have not been examined in the literature, we came in contact with TrailOfBits, a security auditing firm, and used their suite of tools to extend the already built taxonomies~\cite{trailofbits}. We utilized the tool Slither to audit smart contracts. We process all the smart contracts with the latest version of the Solidity compiler, in order to get the most updated list of warnings and errors. 

Slither is a static analyzer and operates on the source code of a smart contract. Its modules (called `detectors') are able to find certain coding patterns which can be considered harmful when present. This includes detecting popular past contract vulnerabilities such as reentrancy or the `Parity bugs'. It should be noted however that it is not able to perform symbolic execution and go through all the possible states of a smart contract like Oyente or Mythril \cite{Luu:2016:MSC:2976749.2978309, mythril}. We describe the currently supported detectors by Slither:

\textbf{Constant/View functions that write to state:} Detects \texttt{view} functions that modify a smart contract's state. A \texttt{view} function uses the \texttt{STATICCALL} opcode and as a result is unable to modify the state of a smart contract\cite{staticcall}. This is not enforced by Solidity.

\textbf{Misnamed constructors that allow modification of `owner'-like variables:} A constructor in a smart contract is a function that is named after the contract name and is run once at deployment. It initializes the contract state and usually sets an \texttt{owner} variable which allows the contract owner to have additional administrative permissions on the contract. If a function does not have the same name as the contract then it is callable at any time after deployment. In past cases, constructors were not named properly and were callable by adversaries who would claim ownership of a contract, leading to theft of funds~\cite{Atzei:2017:SAE:3080353.3080363}.

\textbf{Reentrancy bugs:} Due to the TheDAO incident (\ref{thedao}) a lot of attention was raised on reentrancy issues. Detecting this class of vulnerability is standard in all auditing tools.

\textbf{Deleting a struct with a mapping inside}: Calling \texttt{delete} on a \texttt{struct} object with a \texttt{mapping} variable does not clear the contents of the mapping\footnote{This is warned for in \url{http://solidity.readthedocs.io/en/v0.4.21/types.html}}. This has not been exploited in the wild, however it can be critical in the case of a banking DApp that keeps track of its users' balances . A full Proof of Concept is given in Appendix \ref{apx:security:mapping}

\textbf{Variable Shadowing:} When a contract (child) that inherits from another contract (parent) defines a variable that already exists in the parent, two separate instances of the variable get stored in the deployed contract. As a result, the state variables of the parent can only be modified by the functions of the parent (the same applies for the child). This has been exploited in smart contract honeypots and is currently undetectable by other automated security tools, explained in Appendix~\ref{honeypots}.

\textbf{Unprotected Function Detection:} If the visibility modifier of a function is set to \texttt{public} or \texttt{external} without any access control mechanism, that function is considered unprotected. This was the cause of the first Parity Wallet hack.

In addition to detecting potential vulnerabilities in smart contracts, Slither's detectors can be used to identify potential code styling issues and recommend fixes:

\textbf{Similar Naming between Variables:} Warns users in the case two variables with same length have very similar names. This is added to encourage more clear and verbose variable naming.

\textbf{Unimplemented Function Detection:} This can be used to ensure the implementation of an interface matches its specification.

\textbf{Unused State Variables:} Detects state variables that are not used in any function and suggests their removal.

\textbf{Wrong Event Prefix:} As per the best practices, the names of `events' should be capitalized. After a discussion on Github\footnote{\url{https://github.com/ethereum/solidity/issues/2877}}, using `emit' for events is going to be mandatory from Solidity 0.5.0 and onwards.

% Slither can be used both for finding known vulnerabilities, but also to avoid common coding anti-patterns. Due to its modular API we can extend it to include more rules. We contributed to the Slither repository by adding support for detecting usage of \texttt{tx.origin} and \texttt{block.blockhash}, which return the original sender of a transaction and the hash of a specified block respectively. The usage of \texttt{tx.origin} should be avoided unless necessary, and as stated in the Solidity documentation can incur in loss of funds\footnote{\url{http://solidity.readthedocs.io/en/v0.4.21/security-considerations.html}}. \texttt{block.blockhash} has been misused in smart contracts and has resulted in theft of funds~\cite{smartbillions}. Table \ref{table:slither} is a modified version of Table 12 from \cite{tools}, including Slither after our contributions, excluding issues that are now detectable by the Solidity compiler.

\input{tables/SlitherComparison.tex}

\subsection{Towards more secure smart contracts}

% Trustless smart contracts are impossible to modify after deployment. If a vulnerability is found, it is impossible to patch it. Developers should keep their code as simple as possible, while providing test coverage for as many scenarios as possible. Using audited and tested code for parts of contracts that have already been implemented, like OpenZeppelin~\cite{zeppelin-solidity}, ensures that these parts of the code are going to be secure. 

Developers must be familiar with the security best practices\footnote{\url{https://consensys.github.io/smart-contract-best-practices/known_attacks/}}, and should look for confluence between the results of different automated analyzers in order to filter out false-positives and find false-negatives. They should also be testing and improving their skills on platforms that have been set up with intentionally vulnerable contracts \cite{ethernaut, hackthiscontract, capturetheether}. Finally, there are techniques which allow a contract to be upgradeable, and thus allowing it to be `patched' in case a vulnerability is foound. It should be taken into account that while the upgradeability feature can be useful in this case, there is increased cost, complexity and gas costs, as well as may introduce additional attack vectors. 