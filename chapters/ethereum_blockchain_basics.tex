\section{Overview}
Before getting into the specifics of blockchains and Ethereum, the next section will be used to explain fundamental terms on cryptograpy and blockchain.

In non technical terms, a blockchain is a database that can be shared by non-trusting individuals without having a central party that maintains the state of the database. Namely, it is a growing list of \textit{blocks} that grows over time. Each block contains various metadata (\textit{blockheaders}) and a number of transactions. A block is chained to its previous one by referencing the previous block's hash. As more blocks get added to the chain, previous blocks and their contents are considered to be more secure.

Any future reference to blockchain terminology such as the contents of a block or a transaction will be referring to the implementations of the Ethereum Platform. The Ethereum Yellowpaper provides details on the formal definitions and contents of each entity~\cite{ethereum}.

\subsection{Public Key Cryptography}
Also refered to as Assymetric Cryptography, it is a system that uses a pair of keys to encrypt and decrypt data. The two keys are usually called \textbf{public} and \textbf{private}, due to the private key being known only to its owner while the public key is known to the public. The main advantage of Public Key Cryptography is the lack of need for a secure channel for the initial exchange of keys between any communicating parties.

The security Public Key Cryptography is based on cryptographic algorithms which are not solvable efficiently due to certain mathematical problems, such as the factorization of large integer numbers for RSA or the discrete logarithm problem for ECDSA, being hard.

When a person encrypts a message with one key, its pair can be used to decrypt the same message. If a message gets encrypted with the private key of the sender, any receiver can verify that the message was indeed sent by the sender as they are the only possible owners of the private key used to enrypt the message. This achieves authentication, and the process is often referred to as \textit{signing} of a message. 

% Insert figure about authentication from the above scheme

\subsection{Cryptographic Hash Functions}

A hash function is any function that is used to map arbitrary size data to fixed size. The result of a hash function is often called the \textit{hash} of its input. Cryptographic hash functions are hash functions that fullfil certain security properties and are used in cryptograpy % Should use something different than wikipedia (https://en.wikipedia.org/wiki/Cryptographic_hash_function).

More specifically, a secure cryptographic hash function should satisfy the following properties (\(H(x)\) refers to the hash of x):
\begin{enumerate}
   \item \textbf{Collision Resistance}: It should be computationally infeasible to find x and y such that \(H(x) = H(y)\). 
   \item \textbf{Pre-Image Resistance}: Given \(H(x)\) it should be computationally infeasible to find \(x\).
   \item \textbf{Second Pre-Image Resistance}: Given \(H(x)\) it should be computationally infeasible to find \(x'\) so that \(H(x') = H(x)\).
\end{enumerate}

Bitcoin uses the SHA-256 cryptographic hash function, while Ethereum uses KECCAK-256. Both functions' outputs are 256 bits long which is considered secure given the document's writing date standards.

It should be noted that although similar, a second preimage attack is significantly more difficult than a preimage attack due to the attacker being able to manipulate only one input in order to cause a collision.
% A Second Preimage Attack is where you are given some data and your task is to find a second set of data which generates the same hash as the first. Itâ€™s very similar yet subtly different to a regular Preimage Attack in that you have a sample of data that you know leads to the target hash value. A Second Preimage is always more difficult to perform than a collision, as one input is outside of the attackers control.

\section{Ethereum Blockchain}

\subsection{Transaction}
The contents of a transaction in Ethereum are as follows:
%TODO more beautiful

\lstinputlisting{code/transaction_example.json}
The fields blockHash, blockNumber, from, to, value, hash are all usual fields that can be found in blockchain transactions. Gas and gasPrice are used for performing computations on the Ethereum platform and will be analyzed in Section X. Ethereum uses an account model compared to Bitcoin's UTXO model [CITE]. In the account model, an attacker can replay a transaction by rebroadcasting it. This is mitigated by adding a nonce to each account's transactions which gets incremented after each transaction. The input field allows embedding extra data to a transaction. This can be used either to add a message or in the case of smart contracts, to have the contents of a function call. The v, r, s parameters are outputs from the Elliptic Curve Digital Signature Algorithms % https://bitcoin.stackexchange.com/questions/38351/ecdsa-v-r-s-what-is-v.

\subsection{Block}
A block is a data structure which is comprised of data forming the block header and transactions. The interesting field for the thesis is the gasLimit field which will be discussed like the transaction gasLimit in section X. 
\lstinputlisting{code/block_example.json}

\subsection{Blockchain}
Blocks refer to the previous blocks recursively until the genesis block (first block in existence), forming a chain of blocks. The set of rules which allow an actor to add a valid block to the blockchain is called a \textit{consensus algorithm}. In order to have consensus in distributed systems, all participating nodes must have the same version (often called history) of the system (blockchain). A malicious node could create an arbitrary block crediting them with any amount of Ether. In order to avoid that, consensus algorithms elect a network participant to decide on the contents of the next block, in a fair manner. This process is often called mining, due to the popularity of the Proof of Work consensus algorithm which allows nodes called \textit{miners} to propose a new block if they solve a hard to compute problem. Consensus algorithms require their problem to be easy to verify however, as when somebody solves the problem and broadcasts it to the network, its solution must be verified swiftly in order to get accepted and propagated to the rest of the network, or rejected. The process of mining and how consensus is achieved is considered outside the scope of this Master Thesis.

\subsection{Blockchain Types}
Blockchains are inspectable and public. Any entity can setup a node, download the full blockchain history and view all the transactions caused by anyone participating in that netwokr. This is one of the main benefits of using a blockchain, transparency.

\begin{figure}[ht]
    \centering
    \includegraphics[width=1.0\textwidth]{blockchain}
    \caption{Blockchain = chain of blocks}
    \label{blockchain}
\end{figure}

We categorize blockchains in two kinds (different authors might have different classifications):
\begin{enumerate}
    \item Public or Permissionless: Low barrier to entry, transparent and immutable.
    \item Private or Permissioned: Federated participation, can obscure certain pieces of data, ability to modify and revert past transactions if needed.
\end{enumerate}

Vitalik Buterin goes indepth in the advantages and disadvantages between private and public blockchains in ~\cite{publicprivate}. Due to the scalability and privacy restrictions of public blockchains, corporations that are looking to include blockchain technology in their processes are looking for a solution NOW, when the research and development is still not at that level. As a result, permissioned blockchains as JP Morgan's Quorum \cite{quorum}, Hyperledger or Corda have arised, with aims to solve these problems.

\subsection{Transactions as State Transitions}
In Bitcoin, the state is created through the Unspent Transaction Outputs set, which defines the amount of BTC  a user can spend. As Ethereum does not use UTXO but an account model, there needs to be a way to monitor the state. This is done through a data structure called Patricia State Trie \cite{Morrison:1968:PAR:321479.321481} which provides an efficient mapping of key and value pairs where the key is the address of the Ethereum account and the value is the Recursive Length Prefix encoding \cite{rlp} of the account's data. % TODO: Explain further or not? https://medium.com/cybermiles/diving-into-ethereums-world-state-c893102030ed

Whenever a transaction gets successfully mined, the world state gets updated accordingly.

\begin{figure}[ht]
    \centering
    \includegraphics[width=1.0\textwidth]{state_transition}
    \caption{After each transaction the state gets updated}
    \label{blockchain}
\end{figure}

\subsection{Ethereum Virtual Machine}
% https://hudsonjameson.com/2017-06-27-accounts-transactions-gas-ethereum/
The Ethereum Virtual Machine is the runtime environment for Ethereum. It is a Turing Complete State machine, allowing arbitrarily complex computations to be executed on it. Ethereum nodes validate blocks and also run the EVM, which means executing the code that is triggered by the transactions (discussed in Section X). Since all nodes redundantly process all transactions and contract executions this process, this can be used by an attacker to maliciously flood the network with transactions and cause multiple computers around the world to perform costly computations forever. There needs to be a computational cost. In Ethereum it is called gas and to the end user it manifests itself as the fees needed for a transaction (be it value transfer or contract call) to complete successfully.

\subsection{Gas}
Every computational step on Ethereum costs gas. The simplest transaction which involves transfering Ether from one account to another costs 21000 gas. Calling functions of a contract involves additional operations whose costs can be estimated through the costs described in~\cite{gas, ethereum}. 

[INSERT GAS / WEI / ETHER denominations]

When refering to blocks, the gasLimit is the cumulative gas that is needed by all transactions included in that block. This is analogous to the block size in Bitcoin and effectively limits the amount of transactions that can be confirmed per block.

Every unit of gas costs a certain amount of \textit{gasPrice} which is set by the sender of the transaction. 
It is the case that:
\begin{equation}
    totalTransactionCost = gasPrice * gasLimit
\end{equation}

Miners are rational players who are looking to maximize their profit. As a result, they include transactions which have higher transaction cost first and transactions with very low transaction fees take longer to confirm.

This effectively creates a fee market  where actors increase the gasPrice value to have them confirmed faster. In the times of network congestion such as popular Initial Coin Offerings [CITE] or mass-driven games such as CryptoKitties [CITE], the network has become very expensive to use and oftentimes unusable with transactions taking hours to confirm [CITE]. 

In the case of a successful transaction, the consumed gas from \textit{gasLimit} goes to miners, while the rest of the gas gets refunded to the sender. After the completion, the world state gets updated.

\begin{figure}[H]
    \centering
    \includegraphics[width=1.0\textwidth]{successful_tx}
    \caption{Successful transaction (from \cite{preethi})}
    \label{successful_tx}
\end{figure}

A transaction can fail for reasons such as not being given enough gas for its computations, or some exception occuring during its execution. In this case, any gas consumed goes to the miners and any changes that would happen are reverted. This is similar to the SQL transaction commit-rollback pattern.

\begin{figure}[H]
    \centering
    \includegraphics[width=1.0\textwidth]{nogas_tx}
    \caption{Out of gas transaction (from \cite{preethi})}
    \label{nogas_tx}
\end{figure}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Programming in Ethereum}
The EVM has its own language called EVM bytecode [REPHRASE]. Programmers often write in higher-level languages such as Solidity and then compile to lower level code. 

\subsection{Programming Languages}
Programmers can write Ethereum Smart Contracts in languages which have compilers designed to compile to EVM bytecode. Such languages are Solidity, Serpent, LLL or Vyper. 

Solidity is the most supported language in the ecosystem and although often comparable to Javascript, we argue that Smart Contracts remind more of C++ or Java, due to their object oriented design. 

\begin{figure}[ht]
    \centering
    \lstinputlisting[language=Solidity]{code/example1.sol}
    \caption{Basic Solidity Smart Contract}
    \label{smart_contract}
\end{figure}

Due to the nascence of these languages and the security mistakes that have occured due to them providing programmers with powerful state-changing functions, there is also progress towards creating functional programming languages such as Bamboo or ones that are formally verifiable.

A compiler is needed to output both the EVM Bytecode and the Application Binary Interface (ABI) so that a third party library can interact with the Smart Contract.


\subsection{Tooling}
The following section describes tools and software that are often used by Ethereum users and developers to interact with the network.
\subsubsection{Client (Node) Implementations and Testnets}
Ethereum's official implementations are Geth (golang) and cpp-ethereum (C++). Third party implementations such as Parity (Rust), Pyethereum (Python) and EthereumJ (Java) also exist. The most used kind of node implementations are Geth (compatible with Rinkeby testnet) and Parity (compatibly with Kovan testnet). 

Smart contracts are immutable once deployed which means that their code cannot change. In addition, they also cost to be deployed, which means that development can get expensive and inefficient. For that, public test networks (testnets) exist which allow for testing free of charge. Kovan and Rinkeby are functioning with the Proof of Authority \cite{poa} consensus algorithm, compared to Ropsten running the Proof of Work \cite{ethash} which is the same as the Ethereum main network's (with less difficulty). 

Comparison between test networks:
\begin{enumerate}
    \item Kovan: Proof of Authority consensus supported by Parity nodes only
    \item Rinkeby: Proof of Authority consensus supported by Geth nodes only
    \item Ropsten: Proof of Work consensus, supported by all node implementations, provides best simulation to the main network 
    % https://ethereum.stackexchange.com/questions/27048/comparison-of-the-different-testnets
\end{enumerate}
% https://ethereum.stackexchange.com/questions/27048/comparison-of-the-different-testnets

In addition, before deploying to a testnet, developers are encouraged to run their own local testnets in order to further their development processes. Geth and Parity allow for setting up private testnets, however the go-to tool for this process is ganache\footnote{\url{http://truffleframework.com/ganache}} (formerly known as testrpc).

\subsubsection{Web3}
Web3 is the library used for interacting with an Ethereum node. The most feature-rich implementation is Web3.js\footnote{\url{https://github.com/ethereum/web3.js}} which is also used for building web interfaces for Ethereum Decentralized Applications (DApps). Implementations for other programming languages are being worked on such as Web3.py\footnote{\url{https://github.com/ethereum/web3.py}}. We showcase an example of connecting and fetching the latest block from Ropsten and Mainnet using Web3.js and Web3.py. The full specifications of each library's API can be found in their documentation\footnote{\url{https://github.com/ethereum/wiki/wiki/JavaScript-API}}\footnote{\url{https://web3py.readthedocs.io/en/stable/}}

\lstinputlisting{code/web3.js}
\lstinputlisting{code/web3.py}

\subsubsection{Truffle}
Truffle is the industry standard framework for smart contract development framework written in Node.JS. It allows for easy deployment and initialization smart contracts along with writing test suites utilizing the Mocha testing framework. Latest versions come together with a debugger and a local testnet like ganache. 

\subsubsection{Docker}
Explain docker...